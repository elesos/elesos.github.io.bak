<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="C++常用语法手册" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="C++98是第一个C++标准，1998年发布。" /><meta property="og:description" content="C++98是第一个C++标准，1998年发布。" /><link rel="canonical" href="https://elesos.github.io/posts/cplusplus-primer/" /><meta property="og:url" content="https://elesos.github.io/posts/cplusplus-primer/" /><meta property="og:site_name" content="艺搜天下" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-07-02T21:17:07+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++常用语法手册" /><meta name="twitter:site" content="@hnrayer" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://elesos.github.io/posts/cplusplus-primer/"},"description":"C++98是第一个C++标准，1998年发布。","url":"https://elesos.github.io/posts/cplusplus-primer/","@type":"BlogPosting","headline":"C++常用语法手册","dateModified":"2022-06-19T18:28:10+08:00","datePublished":"2021-07-02T21:17:07+08:00","@context":"https://schema.org"}</script><title>C++常用语法手册 | 艺搜天下</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="艺搜天下"><meta name="application-name" content="艺搜天下"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">艺搜天下</a></div><div class="site-subtitle font-italic">知行合一 以人为镜</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/starRTC" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/hnrayer" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['admin','elesos.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>C++常用语法手册</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++常用语法手册</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> elesos </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2021-07-02, 21:17 +0800" >2021-07-02<i class="unloaded">2021-07-02T21:17:07+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2022-06-19, 18:28 +0800" >2022-06-19<i class="unloaded">2022-06-19T18:28:10+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6312 字">35 分钟 阅读</span></div></div><div class="post-content"><p>C++98是第一个C++标准，1998年发布。</p><p>C++11，第三个C++标准，2011年</p><p>C++14，第四个C++标准，2014年</p><p>C++17，第五个C++标准，2017年</p><p>C++20 , 2020</p><p>下一代是C++23</p><h2 id="关键字">关键字</h2><p>https://www.runoob.com/w3cnote/cpp-keyword-intro.html</p><p>C++库 https://en.cppreference.com/w/cpp/links/libs</p><p>范围for</p><p>using代替typedef</p><p><code class="language-plaintext highlighter-rouge">using SI=Sales_item</code></p><p>用vector和迭代器代替数组和指针</p><p>用string代替c风格字符串 常量对象只能调用常成员函数</p><p>拷贝构造函数何时调用：</p><p>一个对象初始化另一个对象；函数参数；返回对象</p><p>构造函数调用顺序：先调用内嵌对象的构造函数，按定义顺序 在类外对静态数据成员定义和初始化</p><p>静态函数成员一般用于访问静态数据成员，如果要访问非静态数据，需要传递对象进来。</p><p>常对象（数据成员不能改变）只能调用常成员函数（不能改数据成员，不能调普通函数）</p><p>explicit 构造函数用来防止隐式转换</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>= default; 指示编译器自动生成函数体
建议重载的方法都加了override 关键字。防止出现不正确的继承行为
</pre></table></code></div></div><p>http://c.biancheng.net/view/400.html</p><p>p792 匿名的命名空间替代static声明</p><h1 id="宏">宏</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>#表示：对应变量字符串化  

##表示：把宏参数名与宏定义代码序列中的标识符连接在一起，形成一个新的标识符
</pre></table></code></div></div><h1 id="namespace">namespace</h1><p>匿名命名空间</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>当定义一个命名空间时，可以忽略这个命名空间的名称：
    namespce {
        char c;
        int i;
        double d;
    }
    编译器在内部会为这个命名空间生成一个唯一的名字，而且还会为这个匿名的命名空间生成一条using指令。所以上面的代码在效果上等同于：
    namespace __UNIQUE_NAME_ {
        char c;
        int i;
        double d;
    }
    using namespace __UNIQUE_NAME_;
</pre></table></code></div></div><p>在匿名命名空间中声明的名称,具有internal链接属性，这和声明为static的全局名称的链接属性是相同的，即名称的作用域被限制在当前文件中</p><p><strong>C++ 新的标准中提倡使用匿名命名空间,而不推荐使用static</strong></p><p>可以在匿名的空间里面声明很多变量和函数,这样可以省去了对每个变量和函数添加static声明. 实质上匿名空间的功能跟static声明是一样的.</p><h1 id="max">max</h1><p>int max: Value of INT_MAX is 2147483647</p><p>https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits?view=msvc-160</p><h1 id="乘法注意">乘法注意</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>interval = 29LL * 24 * 3600 * 1000;
</pre></table></code></div></div><p>不加LL会在赋值之前就溢出</p><h1 id="常用运算符">常用运算符</h1><h2>%</h2><p>取模运算符“%”的作用是求两个数相除的余数。</p><p>通常用来判断一个数是否能被另一个数整除。</p><p>向上取整 ceil</p><h1 id="文件读写">文件读写</h1><p>https://www.cplusplus.com/reference/cstdio/fread/</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> fseek (pFile , 0 , SEEK_END);
 lSize = ftell (pFile);
 rewind (pFile); //Set position of stream to the beginning
</pre></table></code></div></div><h1 id="stdatomic-用法">Std::atomic 用法</h1><p>C++中对共享数据的存取在并发条件下可能会引起data race的undifined行为，需要限制并发程序以某种特定的顺序执行，有两种方式：使用mutex保护共享数据，原子操作</p><p>原子类型操作要不一步完成，要么不做，不可能出现操作一半被切换CPU，这样防止由于多线程指令交叉执行带来的可能错误。非原子操作下，某个线程可能看见的是一个其它线程操作未完成的数据。</p><p>atomic 原子操作支持bool、int、char等数据类型</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>std::atomic &lt;bool&gt;   atomic_bool_test1(false);
a.load() 返回数值a的copy
</pre></table></code></div></div><h1 id="stdasync">Std::async</h1><p>Call function asynchronously</p><p>https://www.cplusplus.com/reference/future/async/</p><p>The value returned by fn can be accessed through the future object returned (by calling its member future::get).</p><h1 id="static-关键字的作用">Static 关键字的作用</h1><p>\1. 全局静态变量</p><p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p><p>静态存储区，在整个程序运行期间一直存在。</p><p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非被显式初始化）；</p><p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义处开始，到本文件结尾。</p><p>\2. 局部静态变量</p><p>在局部变量前加上关键字static，局部变量就成为一个局部静态变量。</p><p>内存中的位置：静态存储区</p><p>初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非被显式初始化）；</p><p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p><p>\3. 静态函数</p><p>函数的定义和声明默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p><p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p><p>注：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p><p>\4. 类的静态成员</p><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p><p>\5. 类的静态函数</p><p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p><p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</p><h1 id="sprintf">Sprintf</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>int sprintf ( char * str, const char * format, ... );
</pre></table></code></div></div><p>stored C string in the buffer pointed by str.</p><p>On success, the total number of characters written is returned. 否则返回负数</p><p>https://www.cplusplus.com/reference/cstdio/sprintf/</p><h1 id="stdbind">Std::bind</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>bind (Fn&amp;&amp; fn, Args&amp;&amp;... args);
</pre></table></code></div></div><p>Returns a function object based on fn, but with its arguments bound to args.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>std::bind(&amp;callback);
std::bind(&amp;aClass::callback, this);
std::bind(&amp;aClass::callback, this， info);
</pre></table></code></div></div><p>https://www.cplusplus.com/reference/functional/bind/</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>using namespace std::placeholders;    // adds visibility of _1, _2, _3  占位
</pre></table></code></div></div><h1 id="stdcondition-variable">Std::condition variable</h1><p>https://www.cplusplus.com/reference/condition_variable/condition_variable/</p><p>block the calling thread until notified to resume.</p><p>It uses a unique_lock to lock the thread when one of its wait functions is called. The thread remains blocked until woken up by another thread that calls a notification function on the same condition_variable object.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>wait  The execution of the current thread  is blocked until notified. 第2个参数：A callable object or function that takes no arguments and returns a value that can be evaluated as a bool. This is called repeatedly until it evaluates to true.
notify_one
notify_all
</pre></table></code></div></div><h1 id="stdremove">Std::remove</h1><p>Remove value from range</p><p>https://www.cplusplus.com/reference/algorithm/remove/</p><h1 id="新特性">新特性</h1><p>c++11开始，可以将大型的对象直接返回，不必担心拷贝代价</p><h1 id="智能指针">智能指针</h1><p>auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，第一个已经被11弃用。</p><p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上避免这个问题， 因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。 所以智能指针的作用就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><h2 id="auto_ptr">auto_ptr</h2><p>c++98的方案，cpp11已经抛弃</p><p>采用所有权模式。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>auto_ptr&lt; string&gt; p1 (new string ("hello world”));
auto_ptr&lt;string&gt;  p2;
p2 = p1; //auto_ptr不会报错.
</pre></table></code></div></div><p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p><h2 id="unique_ptr">unique_ptr</h2><p>unique_ptr（替换auto_ptr）</p><p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露 (例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p><p>采用所有权模式，还是上面那个例子</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>unique_ptr&lt;string&gt; p3 (new string ("auto"));   //#4
unique_ptr&lt;string&gt; p4；                       //#5
p4 = p3;//此时会报错！！
</pre></table></code></div></div><p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p><p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做； 如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>unique_ptr&lt;string&gt; pu1(new string ("hello world"));
unique_ptr&lt;string&gt; pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr&lt;string&gt; pu3;
pu3 = unique_ptr&lt;string&gt;(new string ("You"));   // #2 allowed
</pre></table></code></div></div><p>其中#1留下悬挂的unique_ptr(pu1)，可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数， 该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。</p><p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>unique_ptr&lt;string&gt; ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);  //#3
ps1 = demo("elesos");
cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;
</pre></table></code></div></div><h2 id="shared_ptr">shared_ptr</h2><p>shared_ptr实现共享式拥有。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时释放。 从名字share就可以看出资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。 可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。 当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p><p>成员函数：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre>use_count 返回引用计数的个数
unique 返回是否是独占所有权( use_count 为 1)
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
reset 放弃内部原对象的所有权, 会引起原有对象的引用计数减少  https://www.cplusplus.com/reference/memory/shared_ptr/reset/

  std::shared_ptr&lt;int&gt; sp;  // empty
  sp.reset (new int);       // takes ownership of pointer
  *sp=10;
  std::cout &lt;&lt; *sp &lt;&lt; '\n';//10

  sp.reset (new int);       // deletes managed object, acquires new pointer
  *sp=20;
  std::cout &lt;&lt; *sp &lt;&lt; '\n';  //20

  sp.reset();               // deletes managed object


get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr&lt;int&gt; sp(new int(1)); sp 与 sp.get()是等价的  ，Returns the stored pointer.   https://www.cplusplus.com/reference/memory/shared_ptr/get/

int* p = new int (10);
 std::shared_ptr&lt;int&gt; a (p);
 if (a.get()==p)
   std::cout &lt;&lt; "a and p point to the same location\n";
 // three ways of accessing the same address:
 std::cout &lt;&lt; *a.get() &lt;&lt; "\n";  //不是a.get()! a.get()==p
 std::cout &lt;&lt; *a &lt;&lt; "\n";
 std::cout &lt;&lt; *p &lt;&lt; "\n";
</pre></table></code></div></div><h2 id="weak_ptr">weak_ptr</h2><p>weak_ptr是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为了配合 shared_ptr 而引入的，用来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造,</p><p>它的构造和析构不会引起引用记数的增加或减少。</p><p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能为0,资源永远不会释放。</p><p>weak_ptr是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，</p><p>它可以通过调用lock函数来获得shared_ptr。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre>class B;
class A{
	public:
	shared_ptr&lt;B&gt; pb_;
	~A(){
		cout&lt;&lt;"A delete\n";
	}
};

class B{
    public:
	shared_ptr&lt;A&gt; pa_;
	~B(){
		cout&lt;&lt;"B delete\n";
	}
};

void fun(){
	shared_ptr&lt;B&gt; pb(new B());
	shared_ptr&lt;A&gt; pa(new A());
	pb-&gt;pa_ = pa;
	pa-&gt;pb_ = pb;
	cout&lt;&lt;pb.use_count()&lt;&lt;endl;
	cout&lt;&lt;pa.use_count()&lt;&lt;endl;
}

int main(){
	fun();
	return 0;
}
</pre></table></code></div></div><p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当跳出函数时，智能指针pa，pb析构时两个资源的引用计数会减一， 但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了， 我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p><p>注意我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>shared_ptr p = pa-&gt;pb_.lock(); 
p-&gt;print();
</pre></table></code></div></div><h1 id="线程thread">线程thread</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>std::thread thread_obj(func, params);

std::thread::join()  //wait for a thread 


 std::thread t1(callable);   // Start thread t1   
 t1.join(); // Wait for t1 to finish
 
 if(joinable()){

}

线程是可结合joinable或者可分离detached的。
一个可结合线程是可以被其它线程回收资源和杀死结束的，
而对于detached状态的线程，其资源不能被其它线程回收和杀死，只能等待线程结束才能由系统自动释放。

只有处于活动状态线程才能调用join，可以通过joinable()函数检查;
join 会使当前线程阻塞，直到目标线程执行完毕
join只能被调用一次，之后joinable就会变为false，表示线程执行完毕；

以下情况不可结合 检查线程是否可被join
1,默认构造的
2，已调用过join或detach
https://vimsky.com/zh-tw/examples/usage/thread-joinable-function-in-c.html



终止线程，需要先设置一个循环退出变量，然后检查是否joinable,然后用join等待退出
</pre></table></code></div></div><h2 id="sleep">sleep</h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>  std::this_thread::sleep_for(std::chrono::seconds(1));
 std::this_thread::sleep_for(std::chrono::milliseconds(interval));
 
 #include &lt;chrono&gt;
 auto start = std::chrono::high_resolution_clock::now(); //
   std::this_thread::sleep_for(2000ms);  //Blocks the execution of the current thread
   auto end = std::chrono::high_resolution_clock::now();
   std::chrono::duration&lt;double, std::milli&gt; elapsed = end-start;
   std::cout &lt;&lt; "Waited " &lt;&lt; elapsed.count() &lt;&lt; " ms\n";   //Waited 2000.12 ms
</pre></table></code></div></div><p>Sleep 函数告诉操作系统 “在未来的多少毫秒内我不参与 CPU 竞争”。</p><p>Thread.Sleep(0) 的作用是 “触发操作系统立刻重新进行一次 CPU 竞争”。竞争的结果也许是当前线程仍然获得 CPU 控制权，也许会换成别的线程获得 CPU 控制权。</p><p>1秒(s) ＝1000毫秒(ms)</p><p>1毫秒(ms)＝1000微秒 (us)</p><p>1微秒(us)＝1000纳秒 (ns)</p><p>1秒=10的9次方</p><p>[https://zh.wikipedia.org/zh-hans/%E6%95%B0%E9%87%8F%E7%BA%A7<em>(%E6%97%B6%E9%97%B4)](https://zh.wikipedia.org/zh-hans/数量级</em>(时间))</p><p>1ks千秒=10的3次方秒</p><p>1Ms兆秒=10的6次方秒</p><p>1吉秒Gs=10的9次方秒，约31.7年。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>离开作用域就释放mutex了
std::lock_guard&lt;std::mutex&gt; lock(io_mutex); //lock_guard是一个类，是mutex的包装 https://en.cppreference.com/w/cpp/thread/lock_guard
std::unique_lock&lt;std::mutex&gt; locker(mutex_); 
</pre></table></code></div></div><p>https://www.cplusplus.com/reference/mutex/unique_lock/</p><p>A <code class="language-plaintext highlighter-rouge">lock_guard</code> always holds a lock from its construction to its destruction. A <code class="language-plaintext highlighter-rouge">unique_lock</code> can be created without immediately locking, can unlock at any point in its existence, and can transfer ownership of the lock from one instance to another.</p><h2 id="detach">detach</h2><p>使用join(),线程运行完,main函数才能结束。</p><p>当使用detach()函数时，主调线程继续运行，被调线程驻留后台运行，主调线程无法再取得该被调线程的控制权。当主调线程结束时，由运行时库负责清理与被调线程相关的资源。使用detach(),main函数不用等待线程结束才能结束。有时候线程还没运行完，main函数就已经结束了。</p><h2 id="参考">参考</h2><p>https://en.cppreference.com/w/cpp/thread/thread/detach</p><p>https://en.cppreference.com/w/cpp/thread/thread/joinable</p><p>https://www.cplusplus.com/reference/thread/thread/detach/</p><p>https://www.geeksforgeeks.org/multithreading-in-cpp/</p><h1 id="常用数据结构">常用数据结构</h1><h2 id="list">list</h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre> std::list&lt;int&gt; first;                                // empty list of ints
 std::list&lt;int&gt; second (4,100);                       // four ints with value 100
 std::list&lt;int&gt; third (second.begin(),second.end());  // iterating through second
 std::list&lt;int&gt; fourth (third);                       // a copy of third
 
 
mylist.push_back(77);

mylist.front()

 std::list&lt; std::pair&lt;int,char&gt; &gt; mylist;
 mylist.emplace_front(10,'a');
 
 mylist.emplace_back(10,'a');
 mylist.emplace_back(20,'b');
 
 first.assign (7,100);                      // 7 ints with value 100
 second.assign (first.begin(),first.end()); // a copy of first
 
 
 std::list&lt; std::pair&lt;int,char&gt; &gt; mylist;
 mylist.emplace ( mylist.begin(), 100, 'x' );
 
erase  根据位置删除
remove 根据值删除
double mydoubles[]={ 12.15,  2.72, 73.0,  12.77,  3.14,  12.77, 73.35, 72.25, 15.3,  72.25 };
std::list&lt;double&gt; mylist (mydoubles,mydoubles+10);
</pre></table></code></div></div><p>https://www.cplusplus.com/reference/list/list/</p><h2 id="string">string</h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>std::string s2 (s0); //copy 
 std::string s3 (s0, 8, 3);  // 获取子串 http://www.cplusplus.com/reference/string/string/string/
 std::string s4 ("A character sequence");
 std::string s5 ("Another character sequence", 12); 
 std::string s6a (10, 'x');   //填充x
 std::string s6b (10, 42);      // 42 is the ASCII code for '*'
 std::string s7 (s0.begin(), s0.begin()+7);
 
 str.size()跟str.length()一样返回大小
str.clear();

assign
append
str.push_back('s');
insert

find_first_of
substr (pos = 0, len = npos)
compare

判断标志npos

const char* data() const;//
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>char greeting[] = "Hello";//C风格 #include &lt;cstring&gt;
strchr(s1, ch);返回指针，指向字符串 s1 中字符 ch 第一次出现的位置，如果输出会输出剩余字符串。
strstr(s1, s2);返回指针，指向字符串 s1 中字符串 s2 第一次出现的位置，如果输出会输出剩余字符串。
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>#include &lt;string&gt;
构造函数：
string s1();         // si = ""
string s2("Hello");  // s2 = "Hello"
string s3(4, 'K');  // s3 = "KKKK"
string s4("12345", 1, 3);  //s4 = "234"，从下标 1 开始，长度为 3 的子串
长度：length 和size
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>子串：
s1 = "this is ok";
s2 = s1.substr(2, 4);  // s2 = "is i"

</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>查找子串和字符，返回值都是子串或字符的位置：
find：从前往后查找子串或字符出现的位置。
rfind：从后往前查找子串或字符出现的位置。
find_first_of：从前往后查找何处出现另一个字符串中包含的字符。如：s1.find_first_of("abc");  //查找s1中第一次出现"abc"中任一字符的位置
find_last_of： 从后往前查找何处出现另一个字符串中包含的字符。
find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。
find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>if ((n = s1.find('u')) != string::npos) //查找 u 出现的位置，查不到则返回静态常量string::npos
       cout &lt;&lt; "1) " &lt;&lt; n &lt;&lt; "," &lt;&lt; s1.substr(n) &lt;&lt; endl;

替换：replace
删除子串：erase 
插入字符串：insert
</pre></table></code></div></div><p>用算法操作string</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
using namespace std;

int main(){
    string s("afgcbed");
    string::iterator p = find(s.begin(), s.end(), 'c');
    if (p!= s.end())
        cout &lt;&lt; p - s.begin() &lt;&lt; endl;  //输出 3
    sort(s.begin(), s.end());
    cout &lt;&lt; s &lt;&lt; endl;  //输出 abcdefg  
    return 0;
}
</pre></table></code></div></div><p>http://www.cplusplus.com/reference/string/string/</p><p>https://www.geeksforgeeks.org/stdstring-class-in-c/</p><p>https://www.tutorialspoint.com/cplusplus/cpp_strings.htm</p><h2 id="vector">vector</h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>c.clear()                   移除容器中所有数据。
c.empty()                 判断容器是否为空。
c.erase(pos)             删除pos位置的数据
c.erase(beg,end)       删除[beg,end)区间的数据
c.front()                  传回第一个数据。
c.insert(pos,elem)      在pos位置插入一个elem拷贝
c.pop_back()            删除最后一个数据。
c.push_back(elem)     在尾部加入一个数据。
emplace_back
c.resize(num)            重新设置该容器的大小
c.size()                    返回容器中实际数据的个数。
c.begin()                  返回指向容器第一个元素的迭代器
c.end()                    返回指向容器最后一个元素的迭代器
</pre></table></code></div></div><h2 id="map">map</h2><h3 id="pair">pair</h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>#include &lt;utility&gt;      // std::pair, std::make_pair

pair &lt;string,double&gt; product1;                     // default constructor
pair &lt;string,double&gt; product2 ("tomatoes",2.30);   // value init
pair &lt;string,double&gt; product3 (product2);          // copy constructor

product1 = make_pair(string("lightbulbs"), 0.99);   // using make_pair (move)
g2 = make_pair(1, 'a');

product2.first = "shoes";                //赋值
product2.second = 39.90;        
</pre></table></code></div></div><p>https://www.cplusplus.com/reference/utility/pair/pair/</p><p>https://www.geeksforgeeks.org/pair-in-cpp-stl/</p><h3 id="map-1">map</h3><p>map are slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration迭代 on subsets based on their order.</p><h4 id="特性">特性</h4><p>元素排了序</p><h4 id="操作">操作</h4><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>mymap.insert ( pair&lt;char,int&gt;('a',100) );  //map_name.insert({key, element})
mymap.insert (it, pair&lt;char,int&gt;('b',300));
anothermap.insert(mymap.begin(),mymap.find('c'));  

map&lt;char,int&gt; mymap;
mymap.emplace('x',100);  //map_name.emplace(key, element)
for (auto &amp;x: mymap)
   cout &lt;&lt; " [" &lt;&lt; x.first &lt;&lt; ':' &lt;&lt; x.second &lt;&lt; ']';
   
   
 find
 
 删除
 mymap.erase (it);  
 mymap.erase ('c');                  // erasing by key
 mymap.erase ( it, mymap.end() );    // erasing by range

clear
count(key) //Count elements with a specific key


 
</pre></table></code></div></div><h4 id="对比">对比</h4><p>all containers (vector, stack, queue, set, map, etc) support both insert and emplace operations.</p><p>emplace不copy of object.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ms.insert(make_pair('b', 25)); 
</pre></table></code></div></div><p>https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/</p><p>https://www.cplusplus.com/reference/map/map/</p><h2 id="类">类</h2><p>protected成员：对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，</p><p>而对于其他的外部class，protected就变成private。</p><h2 id="lambda">Lambda</h2><p>方便定义匿名函数</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>[capture list] (params list) mutable exception-&gt; return type { function body }
[capture list] (params list) -&gt; return type {function body}
[capture list] (params list) {function body}
[capture list] {function body}
</pre></table></code></div></div><p>capture list：捕获外部变量列表 , &amp;, a, b除a和b按值进行传递外，其他参数都按引用进行传递。 a, &amp;b 将a按值进行传递，b按引用进行传递。 =，&amp;a, &amp;b 除a和b按引用进行传递外，其他参数都按值进行传递。</p><p>params list：形参</p><p>mutable指示符：用来说明是否可以修改捕获的变量</p><p>exception：异常设定</p><p>return type：返回类型</p><p>function body：函数体</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>int a = 123;
  auto f = [a]()mutable { cout &lt;&lt; ++a; }; // 不会报错
  cout &lt;&lt; a &lt;&lt; endl; // 输出：123
  f(); // 输出：124
</pre></table></code></div></div><h3 id="可调用对象">可调用对象</h3><p>对于一个对象或者一个表达式，如果可以对其使用调用运算符，则称为可调用对象，如果类定义了调用运算符，则该类的对象称作函数对象</p><p>一个 lambda 表达式表示一个可调用的代码单元</p><p>头文件相互包含：</p><p>a) 分别定义ClassA和ClassB，并在cpp文件中实现之 b) 在两个头文件的开头分别用class ClassB;和class ClassA;声明对方 c) 在两个cpp文件中分别包含另外一个类的头文件</p><p>这种方法切记不可使用类名来定义变量和函数的变量参数，只可用来定义引用或者指针。</p><h1 id="winsock">Winsock</h1><p>https://docs.microsoft.com/en-us/windows/win32/winsock/getting-started-with-winsock</p><p>f a server wants to listen on both IPv6 and IPv4, two listen sockets must be created, one for IPv6 and one for IPv4. These two sockets must be handled separately by the application.Windows Vista and later offer the ability to create a single IPv6 socket that is put in dual stack mode to listen on both IPv6 and IPv4.</p><p>如果有相关包含错误：</p><p>#define WIN32_LEAN_AND_MEAN</p><h1 id="远程调试">远程调试</h1><p>https://docs.microsoft.com/zh-cn/visualstudio/debugger/remote-debugging-cpp?view=vs-2019</p><p>1,安装远程工具并启动</p><p>2,在“解决方案资源管理器”中，右键单击该项目并选择“属性”。 打开“调试”选项卡。将“要启动的调试器”更改为“远程 Windows 调试器” 。</p><p><img data-proofer-ignore data-src="/images/2022/c/remote_debug.png" alt="remote_debug" /></p><h1 id="时间转换">时间转换</h1><p>类型time_t</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>strftime ：格式化struct tm；
那结构体如何构造？localtime 可以返回，通过传time_t 
time_t sec = (time_t)1647993599;
struct tm * timeinfo = localtime(&amp;sec);
char buffer[80];
strftime(buffer, 80, "%Y-%m-%d", timeinfo);

</pre></table></code></div></div><p>虚基类</p><p>https://www.cnblogs.com/qrlozte/p/4168807.html</p><p>典型的需要用虚基类的情况如下： A / <br /> B C \ / D 其中D继承自BC,BC分别继承自A,所以A要分别<strong>被BC</strong>虚拟继承</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>class B:virtual public A;
class C:virtual public A;
class D:public B,public C;
</pre></table></code></div></div><p>进制</p><p>二进制使用时必须以<code class="language-plaintext highlighter-rouge">0b</code>或<code class="language-plaintext highlighter-rouge">0B</code>（不区分大小写）开头</p><h2 id="常成员函数---const-关键字">常成员函数 - const 关键字</h2><p>函数名（参数表）const；</p><p>在实现部分也要带该关键字。</p><p>const关键字可以用于对重载函数的区分。</p><p>常成员函数不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。</p><p>常成员函数可以被其他成员函数调用。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%89%BA%E6%90%9C%E7%A7%91%E6%8A%80/'>艺搜科技</a>, <a href='/categories/%E7%BC%96%E7%A8%8B/'>编程</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++常用语法手册 - 艺搜天下&url=https://elesos.github.io/posts/cplusplus-primer/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++常用语法手册 - 艺搜天下&u=https://elesos.github.io/posts/cplusplus-primer/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++常用语法手册 - 艺搜天下&url=https://elesos.github.io/posts/cplusplus-primer/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/use-notepad-batch-change-utf8/">使用 notepad++宏 批量替换文件编码</a><li><a href="/posts/wechat-mp-devel-faq/">微信公众号开发常见问题</a><li><a href="/posts/post-standard/">定一个博客写作标准</a><li><a href="/posts/scrapy-install/">Scrapy 安装</a><li><a href="/posts/ngrok-rpi/">Ngrok 内网穿透 树莓派</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E4%B9%A6%E6%91%98/">书摘</a> <a class="post-tag" href="/tags/c/">c</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/qt/">qt</a> <a class="post-tag" href="/tags/%E8%89%BA%E6%90%9C%E7%99%BE%E7%A7%91/">艺搜百科</a> <a class="post-tag" href="/tags/%E8%89%BA%E6%90%9C%E8%BD%AF%E4%BB%B6/">艺搜软件</a> <a class="post-tag" href="/tags/php/">php</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/ffmpeg/">ffmpeg</a> <a class="post-tag" href="/tags/linux/">linux</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/c-cplusplus-call-each-other/"><div class="card-body"> <span class="timeago small" >2021-07-02<i class="unloaded">2021-07-02T08:13:01+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>c++与其它语言的互相调用</h3><div class="text-muted small"><p> C++调C #ifdef __cplusplus extern "C" { // 告诉编译器下列代码要以C链接约定的模式进行链接 #endif //c头文件或函数 #ifdef __cplusplus } #endif C++中调用C库 做一个C动态库： #include &lt;stdio.h&gt; void hello(){ } g...</p></div></div></a></div><div class="card"> <a href="/posts/recommend-c-framework-and-library/"><div class="card-body"> <span class="timeago small" >2021-07-04<i class="unloaded">2021-07-04T10:30:54+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>值得推荐的C和C++框架和库</h3><div class="text-muted small"><p> 包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。 标准库 C++标准库，包括了STL容器，算法和函数等。 C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。 Standard Template Library：标准模板库STL C POSIX library ： P...</p></div></div></a></div><div class="card"> <a href="/posts/boost-primer/"><div class="card-body"> <span class="timeago small" >2021-09-19<i class="unloaded">2021-09-19T17:15:14+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Boost简明教程</h3><div class="text-muted small"><p> 编译 Boost.Jam（BJam）包含在知名的Boost C++ library 中，類似make 的建構工具。 bjam.exe 是老版本，b2是bjam的升级版本 vs2017 bjam.exe install –prefix=”boost_1_70_vs2017” –libdir=”boost_1_70_vs2017/lib/Win” –toolset=msvc-14.1 l...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/recommend-c-books/" class="btn btn-outline-primary" prompt="上一篇"><p>C++经典书籍推荐</p></a> <a href="/posts/flv-format/" class="btn btn-outline-primary" prompt="下一篇"><p>FLV格式</p></a></div><div class="utterances-container"> <script src="https://utteranc.es/client.js" repo="elesos/elesos.github.io" issue-term="title" label="Comment" theme="github-dark" crossorigin="anonymous" async> </script></div><script type="text/javascript"> $(function() { window.onmessage = evt => { if (evt.origin === 'https://utteranc.es') { toggle.updateCommentStyle(); window.onmessage = null; } } }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/hnrayer">elesos</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/%E4%B9%A6%E6%91%98/">书摘</a> <a class="post-tag" href="/tags/c/">c</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/qt/">qt</a> <a class="post-tag" href="/tags/%E8%89%BA%E6%90%9C%E7%99%BE%E7%A7%91/">艺搜百科</a> <a class="post-tag" href="/tags/%E8%89%BA%E6%90%9C%E8%BD%AF%E4%BB%B6/">艺搜软件</a> <a class="post-tag" href="/tags/php/">php</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/ffmpeg/">ffmpeg</a> <a class="post-tag" href="/tags/linux/">linux</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
