---
layout: post
title: c sizeof
date: 2021-07-04 10:39:37 +0800
categories: [艺搜科技,编程]
tags: [C/C++]
---

功能：计算字节数

所有指针变量的sizeof结果均为4。

```
int *p;
sizeof(p)=4;但sizeof(*p)相当于sizeof(int);
int a[10];
sizeof(a)等于4*10=40;
```

注意对比与strlen的不同：计算字符串的长度，且长度不包括’\0’

## 结构体的空间计算

遵循两个原则：

(1)整体空间是 占用空间最大的成员的类型所占字节数的整倍数

(2)数据对齐原则：内存按结构成员的先后顺序排列，当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整倍数，如果不够则补齐。

```
struct s1{
 char a;
 double b;//8
 int c;
 char d;
};
 
struct s2{
 char a;
 char b;
 int c;
 double d;
};
 
cout<<sizeof(s1)<<endl;// 24
cout<<sizeof(s2)<<endl;// 16
```

同样是两个char型，一个int，一个double型，

但因为对齐问题，导致他们的大小不同。

计算结构体大小可以采用元素摆放法，首先判断结构体的对界，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。

对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素b是double类型，要放到8的对界上，离1最接近的地址是8了，所以b被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。

对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。

## 参考

http://en.wikipedia.org/wiki/Sizeof

http://en.cppreference.com/w/cpp/language/sizeof
