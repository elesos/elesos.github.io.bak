---
layout: post
title: C++ 常用指针类型小结
date: 2022-04-30 05:30:00 +0800
categories: [c++]
tags: [c++]
---
指针变量的值是地址

原则: 从变量名开始,根据运算符优先级结合,一步一步分析.
```
int p;     //整型变量
int *p;   //首先从变量名p 处开始,先与*结合,说明p 是一个指针,然后再与int 结合,说明指针所指向内容的类型为int 型.所以p 是一个返回整型数据的指针
int p[3]; //首先从变量名p 处开始,先与[]结合,说明p 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以p 是一个由整型数据组成的数组
```
指针数组：
```
int *p[3]; //首先从变量名p 处开始, 先与[]结合,因为其优先级比*高,所以p 是一个数组,然后与*结合,说明数组里的元素都是指针类型,然后再与int 结合,说明指针所指向内容的类型是整型的,所以p 是一个由  返回整型数据的指针  所组成的数组
```
每个元素都是指针变量, 每个元素都是一个（指向int型数据的）指针
```
int (*p)[3]; //首先从变量名p 处开始, 先与*结合,说明p 是一个指针，然后再与[]结合,说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以p是一个指向 由整型数据组成的数组  的指针
p指向（包含3个整型元素）一维数组
float (*p)[25][10];  p=new float[10] [25][10];//new产生一个指向25*10的二维数组的指针,数组元素的个数为:除最左边一维外,其它各维的乘积
int **p; //首先从p 开始,先与*结合,说明是p 是一个指针,然后再与*结合,说明指针所指向的元素也是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.  
指向函数的指针：

int (*p)(int); //从变量名p 处开始,先与指针结合,说明p 是一个指针,然后与()结合,说明指针指向的是一个函数,所以p 是一个指向由一个整型参数且返回类型为整型的函数的指针
指针函数：返回类型为指针，函数结束时可返回大量数据
```
指向常量的指针：
```
const  int *pa=&a;
```
常量指针：
```
int *pa=&a;  --->  int *const pa=&a;相当于在*pa中间加了const
指向类的非静态成员的指针：只能访问到公有成员(公有数据+公有函数)，但公有函数成员可以访问类的私有数据

A    a,*p2;
Int A::*p1;//声明指向公有数据成员的指针   
int (A::*p3)( 形参);//声明指向公有函数成员的指针

p1=&A::x;//x为公有数据 
p3=&A::GetX;//&可省
```
以下为调用

a.*p1//等价于a.x    或p2->*p1;
(a.*p3)(实参)；或(p2->*p3)(实参);  //或(p2->GetX)();或p2->GetX(); a.GetX();
指向类的静态成员的指针：对静态成员的访问不需要对象，用普通指针即可

int *p=&Point::countP;// countP为静态数据
void (*fun)()=Point::GetC;//声明一个指向函数的指针，指向静态成员函数  调用 fun();//或(*fun)()
指向结构体指针的指针
```
struct tag
{
char*   name;
int    num;
 
}**ptr;

//如果sizeof里面有一个*,前面强制转换的地方就需要再加一个*,也就是2个*
ptr=(struct tag **)malloc(10*sizeof(struct tag*));   

for ( i=0 ;i <10; i++)
{
    ptr[i] = (struct tag* )malloc( 10* sizeof( struct tag));// 如果后面没有*,则前面强制转换时加一个*
    ptr[i]->name = (char*) malloc(10);
    strcpy(ptr[i]->name,"test");
    ptr[i]->num = i;
}
```